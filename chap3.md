# [Starting FORTH](https://1scyem2bunjw1ghzsf1cjwwn-wpengine.netdna-ssl.com/wp-content/uploads/2018/01/Starting-FORTH.pdf) (p. 59 〜)

大概の FORTH システムではディスクメモリを使用する。  
たとえ必ずディスクメモリを使用するわけではないとしても、  
それ無しで FORTH について考えることはできない。

ディスクメモリが何をしているか理解するために、それを RAM と比較する。  
その違いは、書類整理棚 と 回転カード式索引 の違いに類似している。

これまでコンピュータのメモリを使ってきたが、それはカード式索引のようなものだ。  
そのコンピュータは殆ど瞬時にこのメモリにアクセスする。そのため RAM に記録された  
プログラムはとても高速に動作する。不運にも、この種のメモリは制限されており、  
比較的高価である。

一方、ディスクは「バルクメモリ: 大容量記憶装置」と呼ばれているため、  
書類整理棚のように、メモリより安価に多くの内容をコンピュータ内部に保存できる。

どちらの種類のメモリでも読み書きされ得る。

コンパイラは辞書のすべての内容をコンパイルして、  
その定義にすばやくアクセスできるようにコンピュータのメモリに書き込む。  
しかしソーステキストを保存するのに最適な場所はディスクであり、  
FORTH もまたそこに保存している。  
ソーステキストは直接キーボードでインタプリタに送るか、ディスク上に保存して後で  
読み出してインタプリタに送ることができる。

ディスクメモリは「ブロック」と呼ばれる単位に分けられる。  
多くの専門的な FORTH の開発環境では 500 ブロックが利用可能となっている。  
( ディスクドライブ毎に 250 ブロック )  
それぞれのブロックがソーステキスト 1024 文字を保持している。  
その 1024 文字は、ターミナル画面に適した形にするために 64 文字毎の 16 行に分割される。

Forth インタプリタそのものが OS として使われていた。  
その影響か、ディスクのブロック番号を直接指定して内容を出力する list ワードや、  
その内容をさらにソーステキストとしてコンパイルする load ワードが存在する。  
( テキストファイルを指定してコンパイルする場合は include ワードを用いる )

# [5.18 Blocks](https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Blocks.html#Blocks)

Gforth をモダンなデスクトップで実行しているとき、ある種のサービスを提供する OS の管理下で動作する。  
これらのサービスのうちひとつはファイルサービスで、Forth のソースコードをファイルに保存して Gforth に読み込むことを可能にする。

伝統的に、Forth は介在する OS が存在しないハードウェアと直接的な関わりを持つシステムにおいて重要なプログラミング言語だった。  
Forth はブロックと呼ばれる機構を提供しており、そのようなシステム上で大規模なストレージにアクセスすることを目的とする。  
ブロックは 1024 バイトの空間であり、データまたは Forth のソースコードを保持するために利用される。  
ブロックの内容において、決まっている構造は存在しない。ブロックはその番号によって特定される。  
なぜなら、ブロックは 1 から処理系によって定義される最大値まで、隣接して番号が振られているからだ。

ブロックが存在するがオペレーティングシステムが存在しない典型的なシステムでは、  
大抵ひとつのフロッピーディスク (256 バイトのセクタを提供するようにフォーマットされたもの) が大容量ストレージとして用いられる。  
最初の 4 セクタに割り当てることでブロック 1 が実現され、次の 4 セクタに割り当てることでブロック 2 が実現され … このようにして、  
ディスクの容量制限の限界まで続く。そのディスクはファイルシステムの情報を含まない、ただのブロックの組である。

実際にファイルサービスが提供されているシステムでは、ブロックの列を１つの「ブロックファイル」に保存することで、  
ブロックが形式的に実装される。ブロックファイルの容量は実際には含んでいるブロックの数に応じて  
1024 バイトの倍数になるものと考えれる。これが Gforth で用いられる機構である。

ただ１つのブロックファイルが同時に開かれる。特定されるブロックファイルがない場合、  
Gforth はデフォルトで ``blocks.fb`` というブロックファイルを生成する。  
Gforth はブロックファイルの位置を特定しようとするときには「サーチパス」を用いる。

プログラムの管理下でブロックを読み書きするとき、Gforth は多くのブロックバッファを中間ストレージとして使用する。  
ブロックの内容を解釈するときに ``load`` ワードを使った場合は、これらのバッファは使用されない。

ブロックの挙動はキャッシュのそれに類似している。それぞれのバッファは 3 種類の状態を持つ。

1. Unassigned
2. Assigned-clean
3. Assigned-dirty

最初は、すべでのブロックが Unassigned となっている。ブロックにアクセスするためには、(ブロック番号で特定された)  
そのブロックはブロックバッファに割り当てられなければならない。

一度ブロックバッファへのブロックの割り当てを ``block`` または ``buffer`` ワードで行うと、  
そのブロックバッファはカレント・ブロックバッファとなる。  
データはカレント・ブロックバッファ内でのみ操作 (読み書き) され得る。

カレント・ブロックバッファが変更されているとき、``block`` または ``buffer`` ワードを用いる前に、  
その変更を破棄するか、または ``update`` ワードを用いてそのブロックバッファの状態を assigned-dirty に変更する必要がある。  
``update`` ワードを用いてもブロックファイルは変更されない。  
それは、単にブロックバッファの状態を assigned-dirty にするだけだからである。  
そのブロックは、バッファが次のブロックを必要としたときに暗黙的に、``flush`` または ``save-buffers`` ワードを用いた時に  
明示的に書き込まれる。
